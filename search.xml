<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Express]]></title>
    <url>%2Fcrr_blog%2F2017%2F08%2F11%2FExpress%2F</url>
    <content type="text"><![CDATA[In ExpressJS 3.x, you may see a line code:1app.use(app.router);Briefly, app.router is the component that knows what to do when you call app.get() etc. See the Connect documentation for the router middleware to understand what it does.Why is order important?If the router middleware was installed before the session middleware, your router handlers would run before the sesssion middleware so the session wouldn’t be setup until after your handler completed; if the route middleware was installed after the errorHandler middleware, errorHandler wouldn’t get a chance to deal with error from your route handler because it would have been run before the router handler got called.Bacically, you need to install app.router explicitly if you have other middleware that you need to ensure come after it in the stack.References:How does app.router work?(SO) app.use(app.router) question (Google Groups)]]></content>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react入门]]></title>
    <url>%2Fcrr_blog%2F2017%2F08%2F10%2Freact%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[React 是近期非常热门的一个前端开发框架。 这篇文章将介绍如何使用 React 来创建用户界面，希望能够起到抛砖引玉的效果。相对于其他框架来说，React 提供了非常少的 API， 如同 Gulp， 越是少量的 API 同时意味着越多的可能性。 正如那句名言所说：Less is more.但是，精简的 API 不是意味着没有一定的学习成本，我们还是需要对此框架进行一定的理解。 闲话不多说，让我们进入正题。首先，让我们来了解下 React 中使用到的一些术语。React 术语术语解释React Elements代表 HTML 元素的 JavaScript 对象。 这些 JavaScript 对象最后被编译成对应的 HTML 元素Components封装 React Elements， 包含一个或者多个 React Elements。 Components 用于创建可以复用的 UI 模块，例如 分页，侧栏导航等JSXJSX 是 React 定义的一种 JavaScript 语法扩展，类似于 XML 。 JSX 是可选的， 我们完全可以使用 JavaScript 来编写 React 应用， 不过 JSX 提供了一套更为简便的方式来写 React 应用Virtual DOMVirtual DOM 是一个模拟 DOM 树的 JavaScript 对象。 React 使用 Virtual DOM 来渲染 UI， 同时监听 Virtual DOM 上数据的变化并自动迁移这些变化到 UI 上DEMO 环境准备首先，在 React Download 页面 下载 Starter Kit，解压到某个地方。进入到解压后的 build 目录，新建一个 index.html 文件，并且引用 react.js 和 JSXTransformer.js 后就可以开始编写 React 应用了。需要注意如果使用 JSX， 那么 script 标签的 type 应该更改为 text/jsx。12345678910111213&lt;html&gt; &lt;head&gt; &lt;meta charset=“utf-8” &gt; &lt;title&gt;demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=“react.js”&gt;&lt;/script&gt; &lt;script src=“JSXTransformer.js”&gt;&lt;/script&gt; &lt;script type=“text/jsx” src=“app.js”&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt;第一个 React Element创建一个 Element 只需调用 React.createElement 方法，并传入元素信息即可。例如：1234var div = React.createElement(‘div’, null, “Hello React”);// 使用 JSXvar div = &lt;div&gt;Hello React&lt;/div&gt;创建之后就可以调用 React.render 方法渲染到页面上：1React.render(div, document.body);第一个 React ComponentReact Component 抽象出相同 UI 组件的结构和逻辑。 通过调用 React.createClass 方法来创建一个 Component，并传入一个带有 render 方法的对象类型的参数。1234567var HelloMessage = React.createClass({ render: function () { return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;; }});React.render(&lt;HelloMessage name=“iissnan” /&gt;, document.body);我们看到 React.createClass 接收了一个对象，并将这个方法返回赋值给 HelloMessage， 最后调用 React.render 方法将这个新建的 Component 渲染到页面上。从这个例子看来，一个 Component 与 Element 并无太大的差别。 事实上， Component 已经准备好了，我们可以增添一些结构和功能来扩展这个 Component 。Props在上一个例子中，可以看到有一个特殊的引用： this.props.name。 这个引用称之为 Props，可以将他想象成 Component 的设置选项。在使用上， Props 类似于 HTML 中的属性：1React.render(&lt;HelloMessage name=“foo” /&gt;, document.body);在 Component 内部，通过 this.props.name 来引用这个 Props：12345var HelloMessage = React.createClass({ render: function () { return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;; }});需要注意的是， Props 仅用来定制 Component， 这些数据不应该被改动。 如果涉及到需要做改动的数据， 得考虑使用 state。Stateful ComponentState 数据代表 Component 的状态， 用于维护 Component 内部的状态。 当 State 发生改变之后， React 将会重新渲染 UI 。调用 与 Props 类似， State 数据通过 this.state 访问：1234567891011121314151617181920212223var Greeting = React.createClass({ getInitialState: function () { return { greeted: false }; }, greet: function () { this.setState({ greeted: true }); }, render: function () { var response = this.state.greeted ? ‘Hi’ : ‘’; return ( &lt;div&gt; &lt;div&gt;Hello {this.props.name}&lt;/div&gt; &lt;span&gt;{response}&lt;/span&gt; &lt;button onClick={this.greet}&gt;Hi&lt;/button&gt; &lt;/div&gt; ); }});React.render(&lt;Greeting name=“foo” /&gt;, document.body);这个例子中加了几个函数，我们一一来看下。 首先是 getInitialState ， 这个方法在 Component 初始化的时候被调用， 返回 Component 初始时的状态数据。例子中，我们设置了 Component 初始时的 greeted 为 false。然后是 greet 方法，这个方法被调用之后将修改状态数据 greeted 为 true。当 State 发生改变后， React 将 Component 渲染到 Virtual DOM，新的 Virtual DOM 与 旧版本的进行比对，检查出改变的部分并更新浏览器的 DOM。 在这个例子中，当按钮被点击后， greeted状态数据发生了变化，UI 跟随着更新。组合结合 Props 和 State，我们就可以使用 Component 来创建完整的应用。1234567891011121314151617181920212223242526272829303132333435var Greeting = React.createClass({ getInitialState: function () { return { greeted: false }; }, greet: function () { this.setState({ greeted: true }); }, render: function () { var response = this.state.greeted ? ‘Hi’ : ‘’; return ( &lt;div&gt; &lt;div&gt;Hello {this.props.name}&lt;/div&gt; &lt;span&gt;{response}&lt;/span&gt; &lt;button onClick={this.greet}&gt;Hi&lt;/button&gt; &lt;/div&gt; ); }});var users = [“foo”, “bar”, “baz”];var GreetingApp = React.createClass({ render: function () { var greetings = this.props.users.map(function (user) { return &lt;Greeting name={user} /&gt;; }); return &lt;div&gt;{greetings}&lt;/div&gt;; }});React.render(&lt;GreetingApp users={users} /&gt;, document.body);]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fcrr_blog%2F2017%2F08%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
